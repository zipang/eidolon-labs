"use strict";

var version = 'v1::';
var offlineFundamentals = [
	'/assets/css/styles.min.css',
	'/assets/js/scripts.min.js',
	'/index.html',
	'/about/index.html',
	'/posts/index.html',
	'/contact/index.html',
];

self.addEventListener("install", function(event) {
	event.waitUntil(
		caches
			.open(version + 'fundamentals')
			.then(function(cache) {
				return cache.addAll(offlineFundamentals);
			})
			.then(function() {
				console.log('worker::installed');
			})
	);
});

self.addEventListener("fetch", function(event) {
	console.log('worker::fetching');

	/* We should only cache GET requests, and deal with the rest of method in the
		 client-side, by handling failed POST,PUT,PATCH,etc. requests.
	*/
	if (event.request.method !== 'GET') {
		/* If we don't block the event as shown below, then the request will go to
			 the network as usual.
		*/
		console.log('worker::fetch ignored |', event.request.method, event.request.url);
		return;
	}

	event.respondWith(
		caches
			/* This method returns a promise that resolves to a cache entry matching
				 the request. Once the promise is settled, we can then provide a response
				 to the fetch request.
			*/
			.match(event.request)
			.then(function(cached) {
				/* Even if the response is in our cache, we go to the network as well.
					 This pattern is known for producing "eventually fresh" responses,
					 where we return cached responses immediately, and meanwhile pull
					 a network response and store that in the cache.

					 Read more:
					 https://ponyfoo.com/articles/progressive-networking-serviceworker
				*/
				var networked = fetch(event.request)
					.then(fetchedFromNetwork, unableToResolve)
					.catch(unableToResolve);

				return cached || networked;

				function fetchedFromNetwork(response) {
					var cacheCopy = response.clone();

					caches.open(version + 'pages')
						.then(function add(cache) {
							cache.put(event.request, cacheCopy);
						})
						.then(function() {
							console.log('worker::fetch cached |', event.request.url);
						});

					return response;
				}

				function unableToResolve () {
					return new Response('<h1>Service Unavailable</h1>', {
						status: 503,
						statusText: 'Service Unavailable',
						headers: new Headers({
							'Content-Type': 'text/html'
						})
					});
				}
			})
	);
});

self.addEventListener("activate", function(event) {
	event.waitUntil(
		caches.keys()
			.then(function (keys) {
				return Promise.all(
					keys
						.filter(function (key) {
							return !key.startsWith(version);
						})
						.map(function (key) {
							return caches.delete(key);
						})
				);
			})
			.then(function() {
				console.log('worker::activated');
			})
	);
});
